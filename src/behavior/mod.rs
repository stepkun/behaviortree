// Copyright Â© 2025 Stephan Kunz
//! Built-In behaviors of [`behaviortree`](crate).

pub mod action;
#[allow(clippy::module_inception)]
pub mod condition;
pub mod control;
pub mod decorator;
pub mod error;
pub mod pre_post_conditions;
mod shared_queue;
mod simple_behavior;
mod sub_tree;

// flatten
pub use error::BehaviorError;
pub use shared_queue::SharedQueue;
pub use simple_behavior::{ComplexBhvrTickFn, SimpleBehavior, SimpleBhvrTickFn};
pub use sub_tree::SubTree;

// region:      --- modules
use alloc::{
	boxed::Box,
	string::{String, ToString},
	vec::Vec,
};
use core::{any::Any, str::FromStr};
use tinyscript::SharedRuntime;

use crate::{
	ACTION, CONDITION, CONTROL, ConstString, DECORATOR, EMPTY_STR, FAILURE, IDLE, RUNNING, SKIPPED, SUBTREE, SUCCESS,
	behavior::pre_post_conditions::Conditions,
	blackboard::{BlackboardInterface, SharedBlackboard},
	port::{PortList, PortRemappings, error::Error, strip_bb_pointer},
	strip_curly_brackets,
	tree::tree_element_list::ConstBehaviorTreeElementList,
};
// endregion:   --- modules

// region:		--- types
/// Pointer to a behavior.
pub type BehaviorPtr = Box<dyn BehaviorExecution>;

/// Result type definition for behaviors.
pub type BehaviorResult<Output = BehaviorState> = Result<Output, BehaviorError>;

/// Type alias for a behavior creation function
pub type BehaviorCreationFn = dyn Fn() -> BehaviorPtr + Send + Sync;

/// [`BehaviorData`] state change callback signature.
///
/// This callback can be used to observe [`BehaviorData`] and manipulate the resulting [`BehaviorState`] of a tick.
pub type BehaviorTickCallback = dyn Fn(&BehaviorData, &mut BehaviorState) + Send + Sync;
// endregion:   --- types

// region:		--- BehaviorDataCollection
/// This is used to minimize the stack consumption during recursion of tree creation
/// and to transport the data collection between function calls.
pub(crate) struct BehaviorDataCollection {
	pub node_name: String,
	pub path: String,
	pub bhvr_desc: BehaviorDescription,
	pub blackboard: SharedBlackboard,
	pub bhvr: Box<dyn BehaviorExecution>,
	pub remappings: PortRemappings,
	pub conditions: Conditions,
	pub uid: u16,
}
// endregion:	--- BehaviorDataCollection

// region:      --- BehaviorExecution
/// Supertrait for execution of a [`Behavior`].
/// The contained functions are generated by the derive macros.
pub trait BehaviorExecution: Any + Behavior {
	/// Dynamic downcasting.
	fn as_any(&self) -> &dyn Any;

	/// Mutable dynamic downcasting.
	fn as_any_mut(&mut self) -> &mut dyn Any;

	/// Provide the boxed creation function.
	fn creation_fn() -> Box<BehaviorCreationFn>
	where
		Self: Sized;

	/// Get the [`BehaviorKind`] of the behavior that shall become a node in a behavior (sub)tree.
	fn kind() -> BehaviorKind
	where
		Self: Sized;

	/// Get the `static` list of defined ports.
	fn static_provided_ports(&self) -> PortList;
}
// endregion:   --- BehaviorExecution

// region:		--- Behavior
/// Defines the methods common to all behaviors.
/// These methods are available when traversing a behavior tree.
#[async_trait::async_trait]
pub trait Behavior: Send + Sync {
	/// Method called during stop/cancel/halt of a behavior,
	/// intended to reset the internal fields of your behavior.
	///
	/// It is not necessary to care about children and maintaining state,
	/// which at this point has already be done by the tree.
	///
	/// Default implementation does nothing.
	/// # Errors
	/// - if something prevents stopping the behavior properly
	#[inline]
	fn on_halt(&mut self) -> Result<(), BehaviorError> {
		Ok(())
	}

	/// Method is called before starting to tick a behavior,
	/// intended to do preliminary stuff for your behavior.
	///
	/// In general it is not necessary to care about children
	/// and maintaining state, which will be done by the
	/// default `start()` method.
	///
	/// Default implementation does nothing.
	/// # Errors
	/// - if something prevents starting the behavior properly
	#[inline]
	fn on_start(
		&mut self,
		_behavior: &mut BehaviorData,
		_children: &mut ConstBehaviorTreeElementList,
		_runtime: &SharedRuntime,
	) -> Result<(), BehaviorError> {
		Ok(())
	}

	/// Method is called on first tick of a behavior instead of `tick()`.
	/// If this method returns [`BehaviorState::Running`], the
	/// behavior becomes asynchronous.
	/// # Errors
	/// - if something prevents starting the behavior properly
	#[inline]
	async fn start(
		&mut self,
		behavior: &mut BehaviorData,
		children: &mut ConstBehaviorTreeElementList,
		runtime: &SharedRuntime,
	) -> BehaviorResult {
		self.on_start(behavior, children, runtime)?;
		self.tick(behavior, children, runtime).await
	}

	/// Method to tick a behavior.
	/// # Errors
	async fn tick(
		&mut self,
		behavior: &mut BehaviorData,
		children: &mut ConstBehaviorTreeElementList,
		runtime: &SharedRuntime,
	) -> BehaviorResult;

	/// Method to halt a behavior.
	/// # Errors
	#[inline]
	fn halt(
		&mut self,
		_behavior: &mut BehaviorData,
		children: &mut ConstBehaviorTreeElementList,
		runtime: &SharedRuntime,
	) -> BehaviorResult {
		children.halt(runtime)?;
		self.on_halt()?;
		Ok(BehaviorState::Idle)
	}

	/// Provide the list of defined ports.
	/// Default implementation returns an empty list.
	#[must_use]
	#[inline]
	fn provided_ports() -> PortList
	where
		Self: Sized,
	{
		PortList::default()
	}
}
// endregion:	--- Behavior

// region:      --- BehaviorData
/// Structure for implementing behaviors.
#[derive(Default)]
pub struct BehaviorData {
	/// UID of the behavior within the [`BehaviorTree`](crate::tree::BehaviorTree).
	/// 65536 behaviors in a [`BehaviorTree`](crate::tree::BehaviorTree) should be sufficient.
	/// The ordering of the uid is following the creation order by the [`XmlParser`](crate::factory::xml_parser::XmlParser).
	/// This should end up in a depth first ordering.
	uid: u16,
	/// Current state of the behavior.
	state: BehaviorState,
	/// List of internal [`PortRemappings`] including
	/// direct assigned values to a `Port`, e.g. default values.
	remappings: PortRemappings,
	/// Reference to the [`Blackboard`] for the element.
	blackboard: SharedBlackboard,
	/// List of pre state change callbacks with an identifier.
	/// These callbacks can be used for observation of the [`BehaviorTreeElement`] and
	/// for manipulation of the resulting [`BehaviorState`] of a tick.
	pre_state_change_hooks: Vec<(ConstString, Box<BehaviorTickCallback>)>,
	/// Description of the Behavior.
	description: BehaviorDescription,
}

impl BehaviorData {
	/// Constructor
	#[must_use]
	pub(crate) fn new(data: &BehaviorDataCollection) -> Self {
		Self {
			uid: data.uid,
			state: BehaviorState::default(),
			remappings: data.remappings.clone(),
			blackboard: data.blackboard.clone(),
			pre_state_change_hooks: Vec::default(),
			description: data.bhvr_desc.clone(),
		}
	}

	/// Delete an entry of type `T` from Blackboard.
	/// # Errors
	/// - if entry is not found
	pub fn delete<T>(&mut self, key: &str) -> Result<T, crate::blackboard::error::Error>
	where
		T: Any + Clone + FromStr + ToString + Send + Sync,
	{
		self.blackboard.delete(key)
	}

	/// Get a value of type `T` from Blackboard.
	/// # Errors
	/// - if value is not found
	pub fn get<T>(&self, key: &str) -> Result<T, Error>
	where
		T: Any + Clone + FromStr + ToString + Send + Sync,
	{
		if let Some(remapped) = self.remappings.find(key) {
			match strip_bb_pointer(&remapped) {
				Some(key) => Ok(self.blackboard.get::<T>(&key)?),
				None => match T::from_str(&remapped) {
					Ok(res) => Ok(res),
					Err(_err) => Err(Error::CouldNotConvert(remapped)),
				},
			}
		} else {
			Ok(self.blackboard.get::<T>(key)?)
		}
	}

	/// Get the sequence ID of a Blackboard entry.
	/// # Errors
	/// - if key is not found in blackboard
	#[inline]
	pub fn get_sequence_id(&self, key: &str) -> Result<usize, crate::blackboard::error::Error> {
		self.blackboard.get_sequence_id(key)
	}

	/// Set a value of type `T` into Blackboard.
	/// Returns old value if any.
	/// # Errors
	/// - if value can not be set
	pub fn set<T>(&mut self, key: &str, value: T) -> Result<Option<T>, Error>
	where
		T: Any + Clone + FromStr + ToString + Send + Sync,
	{
		if let Some(remapped) = self.remappings.find(key) {
			let stripped_key = strip_curly_brackets(&remapped);
			Ok(self.blackboard.set::<T>(stripped_key, value)?)
		} else {
			Ok(self.blackboard.set::<T>(key, value)?)
		}
	}

	/// Method to access the blackboard.
	#[must_use]
	pub const fn blackboard(&self) -> &SharedBlackboard {
		&self.blackboard
	}

	/// Method to access the blackboard mutable.
	#[must_use]
	pub const fn blackboard_mut(&mut self) -> &mut SharedBlackboard {
		&mut self.blackboard
	}

	/// Method to get the desription.
	#[must_use]
	pub const fn description(&self) -> &BehaviorDescription {
		&self.description
	}

	/// Method to get the desription mutable.
	#[must_use]
	pub const fn description_mut(&mut self) -> &mut BehaviorDescription {
		&mut self.description
	}

	/// Method to get the uid.
	#[must_use]
	pub const fn uid(&self) -> u16 {
		self.uid
	}

	/// Method to get the state.
	#[must_use]
	pub const fn state(&self) -> BehaviorState {
		self.state
	}

	/// Method to set the state.
	pub fn set_state(&mut self, state: BehaviorState) {
		if state != self.state {
			// Callback before setting state
			let mut state = state;
			for (_, callback) in &self.pre_state_change_hooks {
				callback(self, &mut state);
			}
			self.state = state;
		}
	}

	/// Add a pre state change callback with the given name.
	/// The name is not unique, which is important when removing callback.
	pub fn add_pre_state_change_callback<T>(&mut self, name: ConstString, callback: T)
	where
		T: Fn(&Self, &mut BehaviorState) + Send + Sync + 'static,
	{
		self.pre_state_change_hooks
			.push((name, Box::new(callback)));
	}

	/// Remove any pre state change callback with the given name.
	pub fn remove_pre_state_change_callback(&mut self, name: &ConstString) {
		// first collect all subscriber with that name ...
		let mut indices = Vec::new();
		for (index, (cb_name, _)) in self.pre_state_change_hooks.iter().enumerate() {
			if cb_name == name {
				indices.push(index);
			}
		}
		// ... then remove them from vec
		for index in indices {
			let _ = self.pre_state_change_hooks.remove(index);
		}
	}

	pub(crate) const fn remappings(&self) -> &PortRemappings {
		&self.remappings
	}
}
// endregion:	--- BehaviorData

// region:		--- BehaviorDescription
/// Description of a Behavior, used in xml parsing and creating.
#[derive(Clone, Debug, Default)]
pub struct BehaviorDescription {
	/// Name of the behavior.
	name: ConstString,
	/// id of the behavior.
	id: ConstString,
	/// Path to the element.
	/// In contrast to BehaviorTree.CPP this path is fully qualified,
	/// which means that every level is denoted explicitly, including the tree root.
	path: ConstString,
	/// Kind of the behavior.
	kind: BehaviorKind,
	/// The [`PortList`]
	ports: PortList,
	/// Flag to indicate whether this behavior is builtin by Groot2.
	groot2: bool,
	/// Path for Groot2
	groot2_path: ConstString,
}

impl BehaviorDescription {
	/// Create a behavior description.
	#[must_use]
	pub fn new(name: &str, id: &str, kind: BehaviorKind, groot2: bool, ports: PortList) -> Self {
		Self {
			name: name.into(),
			id: id.into(),
			path: EMPTY_STR.into(),
			kind,
			ports,
			groot2_path: EMPTY_STR.into(),
			groot2,
		}
	}

	/// Get name
	#[must_use]
	pub const fn name(&self) -> &ConstString {
		&self.name
	}

	/// Method to set the name.
	pub fn set_name(&mut self, name: &str) {
		self.name = name.into();
	}

	/// Get id
	#[must_use]
	pub const fn id(&self) -> &ConstString {
		&self.id
	}

	/// Method to get the path.
	#[must_use]
	pub const fn path(&self) -> &ConstString {
		&self.path
	}

	/// Method to set the path.
	pub fn set_path(&mut self, path: &str) {
		self.path = path.into();
	}

	/// Get kind
	#[must_use]
	pub const fn kind(&self) -> BehaviorKind {
		self.kind
	}

	/// Get kind as str
	#[must_use]
	pub const fn kind_str(&self) -> &'static str {
		self.kind.as_str()
	}

	/// Get ports
	#[must_use]
	pub const fn ports(&self) -> &PortList {
		&self.ports
	}

	/// If is builtin of Groot2
	#[must_use]
	pub const fn groot2(&self) -> bool {
		self.groot2
	}

	/// Get the path for Groot2.
	#[must_use]
	pub const fn groot2_path(&self) -> &ConstString {
		&self.groot2_path
	}

	/// Set the path for Groot2.
	pub fn set_groot2_path(&mut self, groot2_path: ConstString) {
		self.groot2_path = groot2_path;
	}
}
// endregion:	--- BehaviorDescription

// region:		--- BehaviorKind

/// All types of behaviors usable in a behavior tree.
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
#[repr(u8)]
pub enum BehaviorKind {
	/// Action
	#[default]
	Action,
	/// Condition
	Condition,
	/// Control
	Control,
	/// Decorator
	Decorator,
	/// Subtree
	SubTree,
}

impl core::fmt::Display for BehaviorKind {
	fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
		write!(f, "{}", self.as_str())
	}
}

impl BehaviorKind {
	/// Provide kind as a static str reference.
	#[must_use]
	pub const fn as_str(&self) -> &'static str {
		match self {
			Self::Action => ACTION,
			Self::Condition => CONDITION,
			Self::Control => CONTROL,
			Self::Decorator => DECORATOR,
			Self::SubTree => SUBTREE,
		}
	}
}
// endregion:	--- BehaviorKind

// region:      --- BehaviorState

/// Behavior state.
///
/// Implementation is as in BehaviorTree.CPP to be able to
/// cooperate with Groot2.
/// IMPORTANT: Behaviors should NEVER return IDLE from a tick.
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
#[repr(u8)]
pub enum BehaviorState {
	/// Behavior is not executing.
	#[default]
	Idle = 0,
	/// Behavior is still executing.
	Running = 1,
	/// Behavior finished with success.
	Success = 2,
	/// Behavior execution failed.
	Failure = 3,
	/// Behavior has been skipped.
	Skipped = 4,
}

impl BehaviorState {
	/// Check if state is signaling that the behavior is active
	#[must_use]
	pub const fn is_active(&self) -> bool {
		matches!(self, Self::Idle | Self::Skipped)
	}

	/// Check if state is signaling that the behavior is completed
	#[must_use]
	pub const fn is_completed(&self) -> bool {
		matches!(self, Self::Success | Self::Failure)
	}

	/// Provide kind as a static str reference.
	#[must_use]
	pub const fn as_str(&self) -> &'static str {
		match self {
			Self::Idle => IDLE,
			Self::Running => RUNNING,
			Self::Success => SUCCESS,
			Self::Failure => FAILURE,
			Self::Skipped => SKIPPED,
		}
	}
}

impl core::fmt::Display for BehaviorState {
	fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
		write!(f, "{}", self.as_str())
	}
}

impl core::str::FromStr for BehaviorState {
	type Err = BehaviorError;

	fn from_str(s: &str) -> Result<Self, Self::Err> {
		let s = s.to_ascii_lowercase();
		let res = match s.as_ref() {
			"idle" => Self::Idle,
			"running" => Self::Running,
			"success" => Self::Success,
			"failure" => Self::Failure,
			"skipped" => Self::Skipped,
			_ => {
				return Err(BehaviorError::ParseError(s.into(), "BehaviorState::from_str()".into()));
			}
		};
		Ok(res)
	}
}
// endregion:   --- BehaviorState
